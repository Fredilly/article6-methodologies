#!/usr/bin/env node
/**
 * Compile standalone AJV validators from /schemas into /scripts/validators.
 * Run ONLY on an internet-connected box that has ajv + ajv-formats installed.
 * Output files are self-contained CJS modules (no runtime deps).
 */
const fs = require('fs');
const path = require('path');
let Ajv, addFormats, standaloneCode;
try {
  Ajv = require('ajv');
  addFormats = require('ajv-formats');
  standaloneCode = require('ajv/dist/standalone').default;
} catch (e) {
  const ROOT_DIR = path.resolve(__dirname, '..');
  const VENDOR = path.join(ROOT_DIR, 'vendor', 'ajv-cli', 'node_modules');
  Ajv = require(path.join(VENDOR, 'ajv'));
  addFormats = require(path.join(VENDOR, 'ajv-formats'));
  standaloneCode = require(path.join(VENDOR, 'ajv', 'dist', 'standalone')).default;
}

const ROOT = path.resolve(__dirname, '..');
const SCHEMAS = [
  { in: 'META.schema.json', out: 'meta.cjs' },
  { in: 'META.previous.schema.json', out: 'meta.previous.cjs' },
  { in: 'sections.schema.json', out: 'sections.cjs' },
  { in: 'rules.schema.json', out: 'rules.cjs' },
];

function compileOne(schemaFile, outFile) {
  const ajv = new Ajv({ strict: true, code: { source: true } });
  addFormats(ajv);
  const schema = JSON.parse(fs.readFileSync(path.join(ROOT, 'schemas', schemaFile), 'utf8'));
  const validate = ajv.compile(schema);
  const code = standaloneCode(ajv, validate);
  let ajvVer = 'unknown';
  try { ajvVer = require('ajv/package.json').version; } catch { try { ajvVer = require(path.join(require('path').resolve(__dirname,'..'),'vendor','ajv-cli','node_modules','ajv','package.json')).version; } catch {} }
  const banner = `/* Standalone validator generated by ajv@${ajvVer}
     Schema: ${schemaFile}
     DO NOT EDIT MANUALLY. Regenerate with: node scripts/compile-audit.js */\n`;
  fs.writeFileSync(path.join(ROOT, 'scripts', 'validators', outFile), banner + code);
  console.log(`wrote scripts/validators/${outFile}`);
}

SCHEMAS.forEach(s => compileOne(s.in, s.out));
